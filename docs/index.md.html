<meta charset="utf-8" emacsmode="-*- markdown -*">

**External Validation of Display Latency in Chrome**
Alex Forrence<br>
September 12, 2022

As part of my [Google Summer of Code 2022 project](https://summerofcode.withgoogle.com/programs/2022/projects/RiwyAVic) to reduce presentation latency in Chrome on Windows, I wanted a way to measure the delay between when something is drawn by the user (e.g. in [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) (rAF)) and when it actually appears on the screen.

# Design

I picked a fairly direct route. Using a phototransistor mounted directly to the monitor and a microcontroller (MCU) for communication, we should be able to get an idea of the presentation latency. Thanks to Chromium's support for the [WebHID API](https://developer.mozilla.org/en-US/docs/Web/API/WebHID_API), the microcontroller can directly coordinate with the browser.

The general idea is this:

![](lag_diagram.png)

The difference in time between the clock reset and the rising edge of the phototransistor voltage *should* give us the total display latency in the system.

It's important to keep in mind that this measurement will only be reliable within a single device/display combination. The display has its own associated delays, depending on the post-processing settings that have been toggled.

## Hardware

I used the following hardware:

 - 1x [Teensy 4.0](https://www.pjrc.com/store/teensy40.html)
 - 1x [HW5P-1 phototransistor](https://www.adafruit.com/product/2831)
 - 1x 10k resistor
 - Misc wires, breadboards, etc. to put it all together

There are probably many other ways to achieve this same basic phenotype (a light-sensitive sensor + a device to interpret that data & communicate with the host computer).

I picked the Teensy 4.0 for a few reasons (beyond already having on hand):

 - It's a high-speed USB 2.0 device, meaning it can send & receive data with very low latency.
 - It has an onboard analog to digital converter (ADC), which is convenient.
 - It has an Arduino-compatible API, which makes it relatively easy for non-electronics people to get hooked up.
 - Great software support from Paul Stoffregen (the creator) & community. The [forums](https://forum.pjrc.com/) are an excellent resource.

The phototransistor was primarily selected because of:

 - Great rise/fall times (~2 μs, according to the [datasheet](https://cdn-shop.adafruit.com/product-files/2831/HW5P-1_2015__1_.pdf))
 - Through hole part, so easy to solder/generally manipulate by hand
 - Minimal supporting circuitry required-- just one resistor!

 ![Circuit schematic](schem.png width="160px") The physical connections are straightforward, mostly boiling down to getting the long & short legs of the phototransistor the right way around (long leg connects to Vcc). This is a [common-collector amplifier](https://www.onsemi.com/pub/Collateral/AN-3005-D.PDF), which has a low voltage output in the dark and high in the light.

The other bit you may want to do is shield the phototransistor from ambient/external light. I've used a (cleaned) bottlecap with holes punched for the phototransistor leads, and that seemed to function well enough. The shield also gives you a surface for attaching tape/other things when mounting the phototransistor to the computer display.

## Software

### Microcontroller

The Teensy's toolchain and libraries are installed and managed through [PlatformIO](https://platformio.org/).

The Teensy 4.0 microcontroller is programmed in C++, and uses prepackaged libraries for timing (https://github.com/luni64/TeensyTimerTool) and configuration of the ADC (https://github.com/pedvide/ADC). The Teensy communicates with the host computer using the Raw HID interface, which uses interrupt transfers to move data between the Teensy and computer. This *should* give us great latency performance-- approximately 125 μs one-way. In reality, we may expect to see significantly worse performance than that, depending on the operating system/software (see this [white paper](http://www.embeddedsys.com/subpages/resources/images/documents/InterruptsAndUSB.pdf) for more).

### Browser

The browser must have the WebHID API available to communicate with the microcontroller (see [caniuse](https://caniuse.com/webhid) for current status). These tests are intended for Chrome on Windows.

# Assessment

### Part 1: Communication Latency

Ideally, the duration of communication between the microcontroller and browser should be minimal (i.e. less than a few milliseconds). Any more may affect our ability to discriminate whether the rising edge of the phototransistor corresponds to one frame or another.



# Alternatives

GPUView, ...

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
